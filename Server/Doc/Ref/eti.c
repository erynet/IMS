/* This file was generated by mib2c and is intended for use as a mib module
   for the ucd-snmp snmpd agent.2626262626262626262626262626262626262626262626262626 */

#include <config.h>

#ifdef IN_UCD_SNMP_SOURCE
/* If we're compiling this file inside the ucd-snmp source tree */


/* This should always be included first before anything else */


/* minimal include directives */
#include "mibincl.h"
#include "util_funcs.h"
#include <time.h>

#else /* !IN_UCD_SNMP_SOURCE */


#include <ucd-snmp/ucd-snmp-config.h>
#include <ucd-snmp/ucd-snmp-includes.h>
#include <ucd-snmp/ucd-snmp-agent-includes.h>


#endif /* !IN_UCD_SNMP_SOURCE */


#include <snmp_alarm.h>
#include <sys/ipc.h>
#include <sys/shm.h>
#include <sys/socket.h>

#include <sys/types.h>


#include "eti_Struct.h"
#include "eti.h"

#define ALARM_INTERVAL		5

#define	TRAP_ON			0x01
#define	TRAP_OFF		0x00


#define TRAPONBATTERY		1
#define TRAPTESTCOMPLETED	2
#define TRAPALARMENTRYADDED	3
#define TRAPALARMENTRYREMOVED	4

int			shmID;
struct UPS  *		ups;
char	    *		imsi;
int 			number 			= 0;
int    			current_Trap[24]	= {0,};
int			previous_Trap[24]	= {0,};
int 			current_number 		= 0;
int 			previous_number 	= 0;

/* 
 * eti_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */


oid eti_variables_oid[] = { 1,3,6,1,2,1,33,1 };

oid upsAlarmBatteryBad[] 	= { 1,3,6,1,2,1,33,1,6,3,1};
oid upsAlarmOnBattery[]	 	= { 1,3,6,1,2,1,33,1,6,3,2};
oid upsAlarmLowBattery[] 	= { 1,3,6,1,2,1,33,1,6,3,3};
oid upsAlarmDepletedBattery[] 	= { 1,3,6,1,2,1,33,1,6,3,4};
oid upsAlarmTempBad[] 		= { 1,3,6,1,2,1,33,1,6,3,5};
oid upsAlarmInputBad[] 		= { 1,3,6,1,2,1,33,1,6,3,6};
oid upsAlarmOutputBad[] 	= { 1,3,6,1,2,1,33,1,6,3,7};
oid upsAlarmOutputOverload[] 	= { 1,3,6,1,2,1,33,1,6,3,8};
oid upsAlarmOnBypass[] 		= { 1,3,6,1,2,1,33,1,6,3,9};
oid upsAlarmBypassBad[] 	= { 1,3,6,1,2,1,33,1,6,3,10};
oid upsAlarmOutputOffAsRequested[] = { 1,3,6,1,2,1,33,1,6,3,11};
oid upsAlarmUpsOffAsRequested[] = { 1,3,6,1,2,1,33,1,6,3,12};
oid upsAlarmChargerFailed[] 	= { 1,3,6,1,2,1,33,1,6,3,13};
oid upsAlarmUpsOutputOff[] 	= { 1,3,6,1,2,1,33,1,6,3,14};
oid upsAlarmUpsSystemOff[] 	= { 1,3,6,1,2,1,33,1,6,3,15};
oid upsAlarmFanFailure[] 	= { 1,3,6,1,2,1,33,1,6,3,16};
oid upsAlarmFuseFailure[] 	= { 1,3,6,1,2,1,33,1,6,3,17};
oid upsAlarmGeneralFault[] 	= { 1,3,6,1,2,1,33,1,6,3,18};
oid upsAlarmDiagnosticTestFailed[] = { 1,3,6,1,2,1,33,1,6,3,19};
oid upsAlarmCommunicationLost[] = { 1,3,6,1,2,1,33,1,6,3,20};
oid upsAlarmAwaitingPower[] 	= { 1,3,6,1,2,1,33,1,6,3,21};
oid upsAlarmShutdownPending[] 	= { 1,3,6,1,2,1,33,1,6,3,22};
oid upsAlarmShutdownImminent[] 	= { 1,3,6,1,2,1,33,1,6,3,23};
oid upsAlarmTestInprogress[] 	= { 1,3,6,1,2,1,33,1,6,3,24};

/* 
 * variable4 eti_variables:
 *   this variable defines function callbacks and type return information 
 *   for the eti mib section 
 */


struct variable4 eti_variables[] = {
/*  magic number        , variable type , ro/rw , callback fn  , L, oidsuffix */
#define   UPSIDENTMANUFACTURER  1
  { UPSIDENTMANUFACTURER, ASN_OCTET_STR , RONLY , var_eti, 2, { 1,1 } },
#define   UPSIDENTMODEL         2
  { UPSIDENTMODEL       , ASN_OCTET_STR , RONLY , var_eti, 2, { 1,2 } },
#define   UPSIDENTUPSSOFTWAREVERSION  3
  { UPSIDENTUPSSOFTWAREVERSION, ASN_OCTET_STR , RONLY , var_eti, 2, { 1,3 } },
#define   UPSIDENTAGENTSOFTWAREVERSION  4
  { UPSIDENTAGENTSOFTWAREVERSION, ASN_OCTET_STR , RONLY , var_eti, 2, { 1,4 } },
#define   UPSIDENTNAME          5
  { UPSIDENTNAME        , ASN_OCTET_STR , RWRITE, var_eti, 2, { 1,5 } },
#define   UPSIDENTATTACHEDDEVICES  6
  { UPSIDENTATTACHEDDEVICES, ASN_OCTET_STR , RWRITE, var_eti, 2, { 1,6 } },
#define   UPSBATTERYSTATUS      7
  { UPSBATTERYSTATUS    , ASN_INTEGER   , RONLY , var_eti, 2, { 2,1 } },
#define   UPSSECONDSONBATTERY   8
  { UPSSECONDSONBATTERY , ASN_INTEGER   , RONLY , var_eti, 2, { 2,2 } },
#define   UPSESTIMATEDMINUTESREMAINING  9
  { UPSESTIMATEDMINUTESREMAINING, ASN_INTEGER   , RONLY , var_eti, 2, { 2,3 } },
#define   UPSESTIMATEDCHARGEREMAINING  10
  { UPSESTIMATEDCHARGEREMAINING, ASN_INTEGER   , RONLY , var_eti, 2, { 2,4 } },
#define   UPSBATTERYVOLTAGE     11
  { UPSBATTERYVOLTAGE   , ASN_INTEGER   , RONLY , var_eti, 2, { 2,5 } },
#define   UPSBATTERYCURRENT     12
  { UPSBATTERYCURRENT   , ASN_INTEGER   , RONLY , var_eti, 2, { 2,6 } },
#define   UPSBATTERYTEMPERATURE  13
  { UPSBATTERYTEMPERATURE, ASN_INTEGER   , RONLY , var_eti, 2, { 2,7 } },
#define   UPSINPUTLINEBADS      14
  { UPSINPUTLINEBADS    , ASN_COUNTER   , RONLY , var_eti, 2, { 3,1 } },
#define   UPSINPUTNUMLINES      15
  { UPSINPUTNUMLINES    , ASN_INTEGER   , RONLY , var_eti, 2, { 3,2 } },
#define   UPSINPUTFREQUENCY     19
  { UPSINPUTFREQUENCY   , ASN_INTEGER   , RONLY , var_upsInputTable, 4, { 3,3,1,2 } },
#define   UPSINPUTVOLTAGE       20
  { UPSINPUTVOLTAGE     , ASN_INTEGER   , RONLY , var_upsInputTable, 4, { 3,3,1,3 } },
#define   UPSINPUTCURRENT       21
  { UPSINPUTCURRENT     , ASN_INTEGER   , RONLY , var_upsInputTable, 4, { 3,3,1,4 } },
#define   UPSINPUTTRUEPOWER     22
  { UPSINPUTTRUEPOWER   , ASN_INTEGER   , RONLY , var_upsInputTable, 4, { 3,3,1,5 } },
#define   UPSOUTPUTSOURCE       23
  { UPSOUTPUTSOURCE     , ASN_INTEGER   , RONLY , var_eti, 2, { 4,1 } },
#define   UPSOUTPUTFREQUENCY    24
  { UPSOUTPUTFREQUENCY  , ASN_INTEGER   , RONLY , var_eti, 2, { 4,2 } },
#define   UPSOUTPUTNUMLINES     25
  { UPSOUTPUTNUMLINES   , ASN_INTEGER   , RONLY , var_eti, 2, { 4,3 } },
#define   UPSOUTPUTVOLTAGE      29
  { UPSOUTPUTVOLTAGE    , ASN_INTEGER   , RONLY , var_upsOutputTable, 4, { 4,4,1,2 } },
#define   UPSOUTPUTCURRENT      30
  { UPSOUTPUTCURRENT    , ASN_INTEGER   , RONLY , var_upsOutputTable, 4, { 4,4,1,3 } },
#define   UPSOUTPUTPOWER        31
  { UPSOUTPUTPOWER      , ASN_INTEGER   , RONLY , var_upsOutputTable, 4, { 4,4,1,4 } },
#define   UPSOUTPUTPERCENTLOAD  32
  { UPSOUTPUTPERCENTLOAD, ASN_INTEGER   , RONLY , var_upsOutputTable, 4, { 4,4,1,5 } },
#define   UPSBYPASSFREQUENCY    33
  { UPSBYPASSFREQUENCY  , ASN_INTEGER   , RONLY , var_eti, 2, { 5,1 } },
#define   UPSBYPASSNUMLINES     34
  { UPSBYPASSNUMLINES   , ASN_INTEGER   , RONLY , var_eti, 2, { 5,2 } },
#define   UPSBYPASSVOLTAGE      38
  { UPSBYPASSVOLTAGE    , ASN_INTEGER   , RONLY , var_upsBypassTable, 4, { 5,3,1,2 } },
#define   UPSBYPASSCURRENT      39
  { UPSBYPASSCURRENT    , ASN_INTEGER   , RONLY , var_upsBypassTable, 4, { 5,3,1,3 } },
#define   UPSBYPASSPOWER        40
  { UPSBYPASSPOWER      , ASN_INTEGER   , RONLY , var_upsBypassTable, 4, { 5,3,1,4 } },
#define   UPSALARMSPRESENT      41
  { UPSALARMSPRESENT    , ASN_GAUGE     , RONLY , var_eti, 2, { 6,1 } },
#define   UPSALARMDESCR         45
  { UPSALARMDESCR       , ASN_OBJECT_ID , RONLY , var_upsAlarmTable, 4, { 6,2,1,2 } },
#define   UPSALARMTIME          46
  { UPSALARMTIME        , ASN_TIMETICKS , RONLY , var_upsAlarmTable, 4, { 6,2,1,3 } },
#define   UPSTESTID             47
  { UPSTESTID           , ASN_OBJECT_ID , RWRITE, var_eti, 2, { 7,1 } },
#define   UPSTESTSPINLOCK       48
  { UPSTESTSPINLOCK     , ASN_INTEGER   , RWRITE, var_eti, 2, { 7,2 } },
#define   UPSTESTRESULTSSUMMARY  49
  { UPSTESTRESULTSSUMMARY, ASN_INTEGER   , RONLY , var_eti, 2, { 7,3 } },
#define   UPSTESTRESULTSDETAIL  50
  { UPSTESTRESULTSDETAIL, ASN_OCTET_STR , RONLY , var_eti, 2, { 7,4 } },
#define   UPSTESTSTARTTIME      51
  { UPSTESTSTARTTIME    , ASN_TIMETICKS , RONLY , var_eti, 2, { 7,5 } },
#define   UPSTESTELAPSEDTIME    52
  { UPSTESTELAPSEDTIME  , ASN_INTEGER   , RONLY , var_eti, 2, { 7,6 } },
#define   UPSSHUTDOWNTYPE       53
  { UPSSHUTDOWNTYPE     , ASN_INTEGER   , RWRITE, var_eti, 2, { 8,1 } },
#define   UPSSHUTDOWNAFTERDELAY  54
  { UPSSHUTDOWNAFTERDELAY, ASN_INTEGER   , RWRITE, var_eti, 2, { 8,2 } },
#define   UPSSTARTUPAFTERDELAY  55
  { UPSSTARTUPAFTERDELAY, ASN_INTEGER   , RWRITE, var_eti, 2, { 8,3 } },
#define   UPSREBOOTWITHDURATION  56
  { UPSREBOOTWITHDURATION, ASN_INTEGER   , RWRITE, var_eti, 2, { 8,4 } },
#define   UPSAUTORESTART        57
  { UPSAUTORESTART      , ASN_INTEGER   , RWRITE, var_eti, 2, { 8,5 } },
#define   UPSCONFIGINPUTVOLTAGE  58
  { UPSCONFIGINPUTVOLTAGE, ASN_INTEGER   , RWRITE, var_eti, 2, { 9,1 } },
#define   UPSCONFIGINPUTFREQ    59
  { UPSCONFIGINPUTFREQ  , ASN_INTEGER   , RWRITE, var_eti, 2, { 9,2 } },
#define   UPSCONFIGOUTPUTVOLTAGE  60
  { UPSCONFIGOUTPUTVOLTAGE, ASN_INTEGER   , RWRITE, var_eti, 2, { 9,3 } },
#define   UPSCONFIGOUTPUTFREQ   61
  { UPSCONFIGOUTPUTFREQ , ASN_INTEGER   , RWRITE, var_eti, 2, { 9,4 } },
#define   UPSCONFIGOUTPUTVA     62
  { UPSCONFIGOUTPUTVA   , ASN_INTEGER   , RONLY , var_eti, 2, { 9,5 } },
#define   UPSCONFIGOUTPUTPOWER  63
  { UPSCONFIGOUTPUTPOWER, ASN_INTEGER   , RONLY , var_eti, 2, { 9,6 } },
#define   UPSCONFIGLOWBATTTIME  64
  { UPSCONFIGLOWBATTTIME, ASN_INTEGER   , RWRITE, var_eti, 2, { 9,7 } },
#define   UPSCONFIGAUDIBLESTATUS  65
  { UPSCONFIGAUDIBLESTATUS, ASN_INTEGER   , RWRITE, var_eti, 2, { 9,8 } },
#define   UPSCONFIGLOWVOLTAGETRANSFERPOINT  66
  { UPSCONFIGLOWVOLTAGETRANSFERPOINT, ASN_INTEGER   , RWRITE, var_eti, 2, { 9,9 } },
#define   UPSCONFIGHIGHVOLTAGETRANSFERPOINT  67
  { UPSCONFIGHIGHVOLTAGETRANSFERPOINT, ASN_INTEGER   , RWRITE, var_eti, 2, { 9,10 } },

};
/*    (L = length of the oidsuffix) */


/*
 * init_eti():
 *   Initialization routine.  This is called when the agent starts up.
 *   At a minimum, registration of your variables should take place here.
 */
void init_eti(void) {


  /* register ourselves with the agent to handle our mib tree */
  REGISTER_MIB("eti", eti_variables, variable4,
               eti_variables_oid);


  if ( (shmID = shmget(KEY, SEGSIZE, IPC_CREAT | 0666)) < 0 )
  {
	perror("\n[eti] Shared Memory Shmget() Failed");
	exit(1);
  }
  printf("[eti] Shared Memory Shmget() Success\n");

  if ( (ups = (struct UPS *) shmat(shmID, 0, 0)) < (struct UPS *)0 )
  {
	perror("[eti] Shared Memory Shmat() Failed");
	exit(1);
  }
  printf("[eti] Shared Memroy Shmat() Success\n");

  printf("sizeof u_char = %d\n", sizeof(u_char));

  /* Alarm Handler Register */
  if ( snmp_alarm_register(ALARM_INTERVAL, SA_REPEAT, Check_Alarm, NULL) == 0)
  {
	snmp_log(LOG_WARNING, "[eti] snmp_alarm_register() : SNMP Alarm Register Failed\n");
  }
  printf("[eti] SNMP Alarm Register Success\n");
 

  /* place any other initialization junk you need here */
}


/*
 * var_eti():
 *   This function is called every time the agent gets a request for
 *   a scalar variable that might be found within your mib section
 *   registered above.  It is up to you to do the right thing and
 *   return the correct value.
 *     You should also correct the value of "var_len" if necessary.
 *
 *   Please see the documentation for more information about writing
 *   module extensions, and check out the examples in the examples
 *   and mibII directories.
 */
unsigned char *
var_eti(struct variable *vp, 
                oid     *name, 
                size_t  *length, 
                int     exact, 
                size_t  *var_len, 
                WriteMethod **write_method)
{


  /* variables we may use later */
  static long long_ret;
  static u_long ulong_ret;
  static unsigned char string[SPRINT_MAX_LEN];
  static oid objid[MAX_OID_LEN];
  static struct counter64 c64;

 

  if (header_generic(vp,name,length,exact,var_len,write_method)
                                  == MATCH_FAILED )
    return NULL;


  /* 
   * this is where we do the value assignments for the mib results.
   */
  switch(vp->magic) {


    case UPSIDENTMANUFACTURER:
        
        *string = 0;
	strcpy(string, ups->upsobjects.upsident.upsIdentManufacturer);
        *var_len = strlen(string);
	printf("upsIdentManufacturer = %s\n", string);
	
        return (unsigned char *) string;

    case UPSIDENTMODEL:
        
        *string = 0;
	strcpy(string, ups->upsobjects.upsident.upsIdentModel);
        *var_len = strlen(string);
	printf("upsIdentModel = %s\n", string);

        return (unsigned char *) string;

    case UPSIDENTUPSSOFTWAREVERSION:

        *string = 0;
	strcpy(string, ups->upsobjects.upsident.upsIdentUPSSoftwareVersion);
        *var_len = strlen(string);
	printf("upsIdentUPSSoftwareversion = %s\n", string);

	return (unsigned char *) string;

    case UPSIDENTAGENTSOFTWAREVERSION:

        *string = 0;
	strcpy(string, ups->upsobjects.upsident.upsIdentAgentSoftwareVersion);
        *var_len = strlen(string);
	printf("upsIdentAgnetSoftwareversion = %s\n", string);

        return (unsigned char *) string;

    case UPSIDENTNAME:
        *write_method = write_upsIdentName;
        *string = 0;
	strcpy(string, ups->upsobjects.upsident.upsIdentName);
	*var_len = strlen(string);
       	printf("upsIdentName = %s\n", string);

	return (unsigned char *) string;

    case UPSIDENTATTACHEDDEVICES:
        *write_method = write_upsIdentAttachedDevices;
        *string = 0;
	strcpy(string, ups->upsobjects.upsident.upsIdentAttachedDevices);
        *var_len = strlen(string);
	printf("upsIdentAttachedDevices = %s\n", string);

        return (unsigned char *) string;

    case UPSBATTERYSTATUS:

        long_ret = 0;
	long_ret = ups->upsobjects.upsbattery.upsBatteryStatus;
	printf("upsBatteryStatus = %d\n", long_ret);

        return (unsigned char *) &long_ret;

    case UPSSECONDSONBATTERY:

        long_ret = 0;
//#siv 10/01
//	long_ret = ups->upsobjects.upsbattery.upsSecondsOnBattery/10;
	long_ret = ups->upsobjects.upsbattery.upsSecondsOnBattery;
//# siv
	printf("upsSecondOnBattery = %d\n", long_ret);

        return (unsigned char *) &long_ret;

    case UPSESTIMATEDMINUTESREMAINING:

        long_ret = 0;
	long_ret = ups->upsobjects.upsbattery.upsEstimatedMinutesRemaining/10;
	printf("upsEstimatedMinutesMaining = %d\n", long_ret);

        return (unsigned char *) &long_ret;

    case UPSESTIMATEDCHARGEREMAINING:

        long_ret = 0;
	long_ret = ups->upsobjects.upsbattery.upsEstimatedChargeRemaining/10;
	printf("upsEstimatedChargerMaining = %d\n", long_ret);

        return (unsigned char *) &long_ret;

    case UPSBATTERYVOLTAGE:

        long_ret = 0;
	long_ret = ups->upsobjects.upsbattery.upsBatteryVoltage/10;
	printf("upsBatteryVoltage = %d\n", long_ret);
//#siv 10/01
        if(long_ret < 0)long_ret = 0;
//#
        return (unsigned char *) &long_ret;

    case UPSBATTERYCURRENT:

        long_ret = 0;
	long_ret = ups->upsobjects.upsbattery.upsBatteryCurrent/10;
	printf("upsBatteryCurrent = %d\n", long_ret);

        return (unsigned char *) &long_ret;

    case UPSBATTERYTEMPERATURE:

        long_ret = 0;
	long_ret = ups->upsobjects.upsbattery.upsBatteryTemperature/10;
	printf("upsBatteryTemperaturer = %d\n", long_ret);

        return (unsigned char *) &long_ret;

    case UPSINPUTLINEBADS:

        long_ret = 0;
	long_ret = ups->upsobjects.upsinput.upsInputLineBads/10;
	printf("upsInputLineBads = %d\n", long_ret);

        return (unsigned char *) &long_ret;

    case UPSINPUTNUMLINES:

        long_ret = 0;
	long_ret = ups->upsobjects.upsinput.upsInputNumLines;
	printf("upsInputNumLines = %d\n", long_ret);

        return (unsigned char *) &long_ret;

    case UPSOUTPUTSOURCE:

        long_ret = 0;
	long_ret = ups->upsobjects.upsoutput.upsOutputSource;
	printf("upsOutputSource = %d\n", long_ret);

        return (unsigned char *) &long_ret;

    case UPSOUTPUTFREQUENCY:

        long_ret = 0;
	long_ret = ups->upsobjects.upsoutput.upsOutputEntry[0].upsOutputFrequency/10;
	printf("upsOutputFrequency = %d\n", long_ret);

        return (unsigned char *) &long_ret;

    case UPSOUTPUTNUMLINES:

        long_ret = 0;
	long_ret = ups->upsobjects.upsoutput.upsOutputNumLines;
	printf("upsOutputNumLines = %d\n", long_ret);

        return (unsigned char *) &long_ret;

    case UPSBYPASSFREQUENCY:

        long_ret = 0;
	long_ret = ups->upsobjects.upsbypass.upsBypassEntry[0].upsBypassFrequency/10;
	printf("upsBypassFrequency = %d\n", long_ret);

        return (unsigned char *) &long_ret;

    case UPSBYPASSNUMLINES:

        long_ret = 0;
	long_ret = ups->upsobjects.upsbypass.upsBypassNumLines;
	printf("upsBypassNumLines = %d\n", long_ret);

        return (unsigned char *) &long_ret;

    case UPSALARMSPRESENT:

        long_ret = 0;
	long_ret = ups->upsobjects.upsalarm.upsAlarmsPresent;
	printf("upsAlarmPresent = %d\n", long_ret);

        return (unsigned char *) &long_ret;

    case UPSTESTID:
        *write_method = write_upsTestId;
        objid[0] = 1;
        objid[1] = 3;
        objid[2] = 6;
        objid[3] = 1;
        objid[4] = 2;
        objid[5] = 1;
        objid[6] = 33;
        objid[7] = 1;
        objid[8] = 7;
        objid[9] = 1;
        *var_len = 10*sizeof(oid);
        return (unsigned char *) objid;

    case UPSTESTSPINLOCK:
        *write_method = write_upsTestSpinLock;
        long_ret = 0;
	long_ret = ups->upsobjects.upstest.upsTestSpinLock;
	printf("upsTestSpinLock = %d\n", long_ret);

        return (unsigned char *) &long_ret;

    case UPSTESTRESULTSSUMMARY:

        long_ret = 0;
	long_ret = ups->upsobjects.upstest.upsTestResultsSummary;
	printf("upsTestResultsSummary = %d\n", long_ret);

        return (unsigned char *) &long_ret;

    case UPSTESTRESULTSDETAIL:

        *string = 0;
	strcpy(string, ups->upsobjects.upstest.upsTestResultsDetail);
        *var_len = strlen(string);
	printf("upsTestResultsDetail = %s\n", string);

        return (unsigned char *) string;

    case UPSTESTSTARTTIME:

        long_ret = 0;
	long_ret = ups->upsobjects.upstest.upsTestStartTime;
	printf("upsTestStartTime = %d\n", long_ret);

        return (unsigned char *) &long_ret;

    case UPSTESTELAPSEDTIME:

        long_ret = 0;
	long_ret = ups->upsobjects.upstest.upsTestElapsedTime;
	printf("upsTestElapsedTime = %d\n", long_ret);

        return (unsigned char *) &long_ret;

    case UPSSHUTDOWNTYPE:
        *write_method = write_upsShutdownType;
        long_ret = 0;
	long_ret = ups->upsobjects.upscontrol.upsShutdownType;
	printf("upsShutdownType = %d\n", long_ret);

        return (unsigned char *) &long_ret;

    case UPSSHUTDOWNAFTERDELAY:
        *write_method = write_upsShutdownAfterDelay;
        long_ret = 0;
	long_ret = ups->upsobjects.upscontrol.upsShutdownAfterDelay;
	printf("upsShutdownAfterDelay = %d\n", long_ret);

        return (unsigned char *) &long_ret;

    case UPSSTARTUPAFTERDELAY:
        *write_method = write_upsStartupAfterDelay;
        long_ret = 0;
	long_ret = ups->upsobjects.upscontrol.upsStartupAfterDelay;
	printf("upsStartupAfterDelay = %d\n", long_ret);

        return (unsigned char *) &long_ret;

    case UPSREBOOTWITHDURATION:
        *write_method = write_upsRebootWithDuration;
        long_ret = 0;
	long_ret = ups->upsobjects.upscontrol.upsRebootWithDuration;
	printf("upsRebootWithDuration = %d\n", long_ret);

        return (unsigned char *) &long_ret;

    case UPSAUTORESTART:
        *write_method = write_upsAutoRestart;
        long_ret = 0;
	long_ret = ups->upsobjects.upscontrol.upsAutoRestart;
	printf("upsAutoRestart = %d\n", long_ret);

        return (unsigned char *) &long_ret;

    case UPSCONFIGINPUTVOLTAGE:
        *write_method = write_upsConfigInputVoltage;
        long_ret = 0;
	long_ret = ups->upsobjects.upsconfig.upsConfigInputVoltage;
	printf("upsConfigInputVoltage = %d\n", long_ret);

        return (unsigned char *) &long_ret;

    case UPSCONFIGINPUTFREQ:
        *write_method = write_upsConfigInputFreq;
        long_ret = 0;
	long_ret = ups->upsobjects.upsconfig.upsConfigInputFreq;
	printf("upsConfigInputFlag = %d\n", long_ret);

        return (unsigned char *) &long_ret;

    case UPSCONFIGOUTPUTVOLTAGE:
        *write_method = write_upsConfigOutputVoltage;
        long_ret = 0;
	long_ret = ups->upsobjects.upsconfig.upsConfigOutputVoltage;
	printf("upsConfigOutputVoltage = %d\n", long_ret);

        return (unsigned char *) &long_ret;

    case UPSCONFIGOUTPUTFREQ:
        *write_method = write_upsConfigOutputFreq;
        long_ret = 0;
	long_ret = ups->upsobjects.upsconfig.upsConfigOutputFreq;
	printf("upsConfigOutputFreq = %d\n", long_ret);

        return (unsigned char *) &long_ret;

    case UPSCONFIGOUTPUTVA:

        long_ret = 0;
	long_ret = ups->upsobjects.upsconfig.upsConfigOutputVA;
	printf("upsConfigOutputVA = %d\n", long_ret);

        return (unsigned char *) &long_ret;

    case UPSCONFIGOUTPUTPOWER:

        long_ret = 0;
	long_ret = ups->upsobjects.upsconfig.upsConfigOutputPower;
	printf("upsConfigOutputPower = %d\n", long_ret);

        return (unsigned char *) &long_ret;

    case UPSCONFIGLOWBATTTIME:
        *write_method = write_upsConfigLowBattTime;
        long_ret = 0;
	long_ret = ups->upsobjects.upsconfig.upsConfigLowBattTime;
	printf("upsConfigLowBattTime = %d\n", long_ret);

        return (unsigned char *) &long_ret;

    case UPSCONFIGAUDIBLESTATUS:
        *write_method = write_upsConfigAudibleStatus;
        long_ret = 0;
	long_ret = ups->upsobjects.upsconfig.upsConfigAudibleStatus;
	printf("upsConfigAudibleStatus = %d\n", long_ret);

        return (unsigned char *) &long_ret;

    case UPSCONFIGLOWVOLTAGETRANSFERPOINT:
        *write_method = write_upsConfigLowVoltageTransferPoint;
        long_ret = 0;
	long_ret = ups->upsobjects.upsconfig.upsConfigLowVoltageTransferPoint;
	printf("upsConfigLowVoltageTransferPoint = %d\n", long_ret);

        return (unsigned char *) &long_ret;

    case UPSCONFIGHIGHVOLTAGETRANSFERPOINT:
        *write_method = write_upsConfigHighVoltageTransferPoint;
        long_ret = 0;
	long_ret = ups->upsobjects.upsconfig.upsConfigHighVoltageTransferPoint;
	printf("upsConfigHighVoltageTransferPoint = %d\n", long_ret);

        return (unsigned char *) &long_ret;


    default:
      ERROR_MSG("");
  }
  return NULL;
}


/*
 * var_upsInputTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_eti above.
 */
unsigned char *
var_upsInputTable(struct variable *vp,
    	    oid     *name,
    	    size_t  *length,
    	    int     exact,
    	    size_t  *var_len,
    	    WriteMethod **write_method)
{


  /* variables we may use later */
  static long long_ret;
//  static float float_ret;
  static u_long ulong_ret;
  static unsigned char string[SPRINT_MAX_LEN];
  static oid objid[MAX_OID_LEN];
  static struct counter64 c64;


  /*
   * This assumes that the table is a 'simple' table.
   *	See the implementation documentation for the meaning of this.
   *	You will need to provide the correct value for the TABLE_SIZE parameter
   *
   * If this table does not meet the requirements for a simple table,
   *	you will need to provide the replacement code yourself.
   *	Mib2c is not smart enough to write this for you.
   *    Again, see the implementation documentation for what is required.
   */
  if (header_simple_table(vp,name,length,exact,var_len,write_method, TABLE_SIZE)
                                                == MATCH_FAILED )
    return NULL;

    number = name[*length - 1 ] -1;

  /*
   * this is where we do the value assignments for the mib results.
   */
  switch(vp->magic) {


    case UPSINPUTFREQUENCY:

  	long_ret = 0;
	long_ret = ups->upsobjects.upsinput.upsInputEntry[number].upsInputFrequency/10;
//      float_ret = 0;
//	float_ret = ups->upsobjects.upsinput.upsInputEntry[number].upsInputFrequency/10.0;
	printf("upsInputFrequency[%d] = %d\n", number, long_ret);

      	return (unsigned char *) &long_ret;
//      return (unsigned char *) &float_ret;

    case UPSINPUTVOLTAGE:

        long_ret = 0;
//#siv10
//	long_ret = ups->upsobjects.upsinput.upsInputEntry[number].upsInputVoltage/10;
	long_ret = ups->upsobjects.upsinput.upsInputEntry[number].upsInputVoltage;
        long_ret = (long_ret %10) >= 5 ? ((long_ret / 10)+1):(long_ret/10);
//
	printf("upsInutVoltage[%d] = %d\n", number, long_ret);

        return (unsigned char *) &long_ret;

    case UPSINPUTCURRENT:

        long_ret = 0;
//#siv 10/01
//	long_ret = ups->upsobjects.upsinput.upsInputEntry[number].upsInputCurrent/10;
	long_ret = ups->upsobjects.upsinput.upsInputEntry[number].upsInputCurrent;
        long_ret = (long_ret %10) >= 5 ? ((long_ret / 10)+1):(long_ret/10);
//#
	printf("upsInutCurrent[%d] = %d\n", number, long_ret);
        return (unsigned char *) &long_ret;

    case UPSINPUTTRUEPOWER:

        long_ret = 0;
	long_ret = ups->upsobjects.upsinput.upsInputEntry[number].upsInputTruePower/10;
	printf("upsInutTruePower[%d] = %d\n", number, long_ret);

        return (unsigned char *) &long_ret;


    default:
      ERROR_MSG("");
  }
  return NULL;
}

/*
 * var_upsOutputTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_eti above.
 */
unsigned char *
var_upsOutputTable(struct variable *vp,
    	    oid     *name,
    	    size_t  *length,
    	    int     exact,
    	    size_t  *var_len,
    	    WriteMethod **write_method)
{


  /* variables we may use later */
  static long long_ret;
  static u_long ulong_ret;
  static unsigned char string[SPRINT_MAX_LEN];
  static oid objid[MAX_OID_LEN];
  static struct counter64 c64;


  /*
   * This assumes that the table is a 'simple' table.
   *	See the implementation documentation for the meaning of this.
   *	You will need to provide the correct value for the TABLE_SIZE parameter
   *
   * If this table does not meet the requirements for a simple table,
   *	you will need to provide the replacement code yourself.
   *	Mib2c is not smart enough to write this for you.
   *    Again, see the implementation documentation for what is required.
   */
  if (header_simple_table(vp,name,length,exact,var_len,write_method, TABLE_SIZE)
                                               == MATCH_FAILED )
    return NULL;

    number = name[*length - 1 ] -1;

  /*
   * this is where we do the value assignments for the mib results.
   */
  switch(vp->magic) {


    case UPSOUTPUTVOLTAGE:

        long_ret = 0;
//#siv 10
//	long_ret = ups->upsobjects.upsoutput.upsOutputEntry[number].upsOutputVoltage/10;
	long_ret = ups->upsobjects.upsoutput.upsOutputEntry[number].upsOutputVoltage;
        long_ret = (long_ret %10) >= 5 ? ((long_ret / 10)+1):(long_ret/10);
//#
	printf("upsOutputVoltage[%d] = %d\n", number, long_ret);
        
        return (unsigned char *) &long_ret;

    case UPSOUTPUTCURRENT:

        long_ret = 0;
//#siv 10/01
//	long_ret = ups->upsobjects.upsoutput.upsOutputEntry[number].upsOutputCurrent/10;
	long_ret = ups->upsobjects.upsoutput.upsOutputEntry[number].upsOutputCurrent;
        long_ret = (long_ret %10) >= 5 ? ((long_ret / 10)+1):(long_ret/10);
//#
	printf("upsOutputCurrent[%d] = %d\n", number, long_ret);

        return (unsigned char *) &long_ret;

    case UPSOUTPUTPOWER:

        long_ret = 0;
	long_ret = ups->upsobjects.upsoutput.upsOutputEntry[number].upsOutputPower/10;
	printf("upsOutputPower[%d] = %d\n", number, long_ret);

        return (unsigned char *) &long_ret;

    case UPSOUTPUTPERCENTLOAD:

        long_ret = 0;
	long_ret = ups->upsobjects.upsoutput.upsOutputEntry[number].upsOutputPercentLoad/10;
	printf("upsOutputPercentLoad[%d] = %d\n", number, long_ret);

        return (unsigned char *) &long_ret;


    default:
      ERROR_MSG("");
  }
  return NULL;
}

/*
 * var_upsBypassTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_eti above.
 */
unsigned char *
var_upsBypassTable(struct variable *vp,
    	    oid     *name,
    	    size_t  *length,
    	    int     exact,
    	    size_t  *var_len,
    	    WriteMethod **write_method)
{


  /* variables we may use later */
  static long long_ret;
  static u_long ulong_ret;
  static unsigned char string[SPRINT_MAX_LEN];
  static oid objid[MAX_OID_LEN];
  static struct counter64 c64;


  /* 
   * This assumes that the table is a 'simple' table.
   *	See the implementation documentation for the meaning of this.
   *	You will need to provide the correct value for the TABLE_SIZE parameter
   *
   * If this table does not meet the requirements for a simple table,
   *	you will need to provide the replacement code yourself.
   *	Mib2c is not smart enough to write this for you.
   *    Again, see the implementation documentation for what is required.
   */
  if (header_simple_table(vp,name,length,exact,var_len,write_method, TABLE_SIZE)
                                                == MATCH_FAILED )
    return NULL;

    number = name[*length - 1 ] -1;

  /* 
   * this is where we do the value assignments for the mib results.
   */
  switch(vp->magic) {


    case UPSBYPASSVOLTAGE:
        
        long_ret = 0;
	long_ret = ups->upsobjects.upsbypass.upsBypassEntry[number].upsBypassVoltage/10;
	printf("upsBypassVoltage[%d] = %d\n", number, long_ret);

        return (unsigned char *) &long_ret;

    case UPSBYPASSCURRENT:
        
        long_ret = 0;
	long_ret = ups->upsobjects.upsbypass.upsBypassEntry[number].upsBypassCurrent/10;
	printf("upsBypassCurrent[%d] = %d\n", number, long_ret);
	
        return (unsigned char *) &long_ret;

    case UPSBYPASSPOWER:
        
        long_ret = 0;
	long_ret = ups->upsobjects.upsbypass.upsBypassEntry[number].upsBypassPower/10;
	printf("upsBypassPower[%d] = %d\n", number, long_ret);
	
        return (unsigned char *) &long_ret;

	
    default:
      ERROR_MSG("");
  }
  return NULL;
}

/*
 * var_upsAlarmTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_eti above.
 */
unsigned char *
var_upsAlarmTable(struct variable *vp,
    	    oid     *name,
    	    size_t  *length,
    	    int     exact,
    	    size_t  *var_len,
    	    WriteMethod **write_method)
{


  /* variables we may use later */
  static long long_ret;
  static u_long ulong_ret;
  static unsigned char string[SPRINT_MAX_LEN];
  static oid objid[MAX_OID_LEN];
  static struct counter64 c64;


  /* 
   * This assumes that the table is a 'simple' table.
   *	See the implementation documentation for the meaning of this.
   *	You will need to provide the correct value for the TABLE_SIZE parameter
   *
   * If this table does not meet the requirements for a simple table,
   *	you will need to provide the replacement code yourself.
   *	Mib2c is not smart enough to write this for you.
   *    Again, see the implementation documentation for what is required.
   */

  int ALARM_TABLE_SIZE = ups->upsobjects.upsalarm.upsAlarmsPresent;
  
  if (header_simple_table(vp,name,length,exact,var_len,write_method, ALARM_TABLE_SIZE)
                                                == MATCH_FAILED )
    return NULL;

    number = name[*length - 1 ] -1;

  /* 
   * this is where we do the value assignments for the mib results.
   */
  switch(vp->magic) {


    case UPSALARMDESCR:
   
        objid[0] = 1;
        objid[1] = 3;
        objid[2] = 6;
        objid[3] = 1;
        objid[4] = 2;
        objid[5] = 1;
        objid[6] = 33;
        objid[7] = 1;
        objid[8] = 6;
        objid[9] = 3;
	
	switch ( ups->upsobjects.upsalarm.upsAlarmEntry[number].upsAlarmDescr )
	{
		case 1: objid[10] = 1; break;
		case 2: objid[10] = 2; break;
		case 3: objid[10] = 3; break;
		case 4: objid[10] = 4; break;
		case 5: objid[10] = 5; break;
		case 6: objid[10] = 6; break;
		case 7: objid[10] = 7; break;
		case 8: objid[10] = 8; break;
		case 9: objid[10] = 9; break;
		case 10: objid[10] = 10; break;
		case 11: objid[10] = 11; break;
		case 12: objid[10] = 12; break;
		case 13: objid[10] = 13; break;
		case 14: objid[10] = 14; break;
		case 15: objid[10] = 15; break;
		case 16: objid[10] = 16; break;
		case 17: objid[10] = 17; break;
		case 18: objid[10] = 18; break;
		case 19: objid[10] = 19; break;
		case 20: objid[10] = 20; break;
		case 21: objid[10] = 21; break;
		case 22: objid[10] = 22; break;
		case 23: objid[10] = 23; break;
		case 24: objid[10] = 24; break;
		default: objid[10] = 0; break;
	}	

        *var_len = 11*sizeof(oid);


  
//		printf("sizeof alarm oid = %d\n", sizeof(objid));

        return (unsigned char *) objid;

    case UPSALARMTIME:
        
        long_ret = 0;
	//long_ret = ups->upsobjects.upsalarm.upsAlarmEntry[number].upsAlarmTime;
        return (unsigned char *) &long_ret;


    default:
      ERROR_MSG("");
  }
  return NULL;
}




int
write_upsIdentName(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
  static unsigned char string[SPRINT_MAX_LEN];
  int size;


  switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR){
              fprintf(stderr, "write to upsIdentName not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(string)){
              fprintf(stderr,"write to upsIdentName: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;


        case RESERVE2:
          size = var_val_len;
          //string = (char *) var_val;


          break;


        case FREE:
             /* Release any resources that have been allocated */
          break;


        case ACTION:
             /* The variable has been stored in string for
             you to use, and you have just been asked to do something with
             it.  Note that anything done here must be reversable in the UNDO case */
          break;


        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;


        case COMMIT:
             /* Things are working well, so it's now safe to make the change
             permanently.  Make sure that anything done here can't fail! */
          break;
  }
  return SNMP_ERR_NOERROR;
}




int
write_upsIdentAttachedDevices(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
  static unsigned char string[SPRINT_MAX_LEN];
  int size;


  switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR){
              fprintf(stderr, "write to upsIdentAttachedDevices not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(string)){
              fprintf(stderr,"write to upsIdentAttachedDevices: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;


        case RESERVE2:
          size = var_val_len;
          //string = (char *) var_val;


          break;


        case FREE:
             /* Release any resources that have been allocated */
          break;


        case ACTION:
             /* The variable has been stored in string for
             you to use, and you have just been asked to do something with
             it.  Note that anything done here must be reversable in the UNDO case */
          break;


        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;


        case COMMIT:
             /* Things are working well, so it's now safe to make the change
             permanently.  Make sure that anything done here can't fail! */
          break;
  }
  return SNMP_ERR_NOERROR;
}




int
write_upsTestId(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
  static oid *objid;
  int size;


  switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OBJECT_ID){
              fprintf(stderr, "write to upsTestId not ASN_OBJECT_ID\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(objid)){
              fprintf(stderr,"write to upsTestId: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;


        case RESERVE2:
          size = var_val_len;
          objid = (oid *) var_val;


          break;


        case FREE:
             /* Release any resources that have been allocated */
          break;


        case ACTION:
             /* The variable has been stored in objid for
             you to use, and you have just been asked to do something with
             it.  Note that anything done here must be reversable in the UNDO case */
          break;


        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;


        case COMMIT:
             /* Things are working well, so it's now safe to make the change
             permanently.  Make sure that anything done here can't fail! */
          break;
  }
  return SNMP_ERR_NOERROR;
}




int
write_upsTestSpinLock(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
  static long *long_ret;
  int size;


  switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER){
              fprintf(stderr, "write to upsTestSpinLock not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long_ret)){
              fprintf(stderr,"write to upsTestSpinLock: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;


        case RESERVE2:
          size = var_val_len;
          long_ret = (long *) var_val;


          break;


        case FREE:
             /* Release any resources that have been allocated */
          break;


        case ACTION:
             /* The variable has been stored in long_ret for
             you to use, and you have just been asked to do something with
             it.  Note that anything done here must be reversable in the UNDO case */
          break;


        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;


        case COMMIT:
             /* Things are working well, so it's now safe to make the change
             permanently.  Make sure that anything done here can't fail! */
          break;
  }
  return SNMP_ERR_NOERROR;
}




int
write_upsShutdownType(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
  static long *long_ret;
  int size;


  switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER){
              fprintf(stderr, "write to upsShutdownType not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long_ret)){
              fprintf(stderr,"write to upsShutdownType: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;


        case RESERVE2:
          size = var_val_len;
          long_ret = (long *) var_val;


          break;


        case FREE:
             /* Release any resources that have been allocated */
          break;


        case ACTION:
             /* The variable has been stored in long_ret for
             you to use, and you have just been asked to do something with
             it.  Note that anything done here must be reversable in the UNDO case */
          break;


        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;


        case COMMIT:
             /* Things are working well, so it's now safe to make the change
             permanently.  Make sure that anything done here can't fail! */
          break;
  }
  return SNMP_ERR_NOERROR;
}




int
write_upsShutdownAfterDelay(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
  static long *long_ret;
  int size;


  switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER){
              fprintf(stderr, "write to upsShutdownAfterDelay not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long_ret)){
              fprintf(stderr,"write to upsShutdownAfterDelay: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;


        case RESERVE2:
          size = var_val_len;
          long_ret = (long *) var_val;


          break;


        case FREE:
             /* Release any resources that have been allocated */
          break;


        case ACTION:
             /* The variable has been stored in long_ret for
             you to use, and you have just been asked to do something with
             it.  Note that anything done here must be reversable in the UNDO case */
          break;


        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;


        case COMMIT:
             /* Things are working well, so it's now safe to make the change
             permanently.  Make sure that anything done here can't fail! */
          break;
  }
  return SNMP_ERR_NOERROR;
}




int
write_upsStartupAfterDelay(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
  static long *long_ret;
  int size;


  switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER){
              fprintf(stderr, "write to upsStartupAfterDelay not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long_ret)){
              fprintf(stderr,"write to upsStartupAfterDelay: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;


        case RESERVE2:
          size = var_val_len;
          long_ret = (long *) var_val;


          break;


        case FREE:
             /* Release any resources that have been allocated */
          break;


        case ACTION:
             /* The variable has been stored in long_ret for
             you to use, and you have just been asked to do something with
             it.  Note that anything done here must be reversable in the UNDO case */
          break;


        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;


        case COMMIT:
             /* Things are working well, so it's now safe to make the change
             permanently.  Make sure that anything done here can't fail! */
          break;
  }
  return SNMP_ERR_NOERROR;
}




int
write_upsRebootWithDuration(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
  static long *long_ret;
  int size;


  switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER){
              fprintf(stderr, "write to upsRebootWithDuration not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long_ret)){
              fprintf(stderr,"write to upsRebootWithDuration: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;


        case RESERVE2:
          size = var_val_len;
          long_ret = (long *) var_val;


          break;


        case FREE:
             /* Release any resources that have been allocated */
          break;


        case ACTION:
             /* The variable has been stored in long_ret for
             you to use, and you have just been asked to do something with
             it.  Note that anything done here must be reversable in the UNDO case */
          break;


        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;


        case COMMIT:
             /* Things are working well, so it's now safe to make the change
             permanently.  Make sure that anything done here can't fail! */
          break;
  }
  return SNMP_ERR_NOERROR;
}




int
write_upsAutoRestart(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
  static long *long_ret;
  int size;


  switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER){
              fprintf(stderr, "write to upsAutoRestart not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long_ret)){
              fprintf(stderr,"write to upsAutoRestart: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;


        case RESERVE2:
          size = var_val_len;
          long_ret = (long *) var_val;


          break;


        case FREE:
             /* Release any resources that have been allocated */
          break;


        case ACTION:
             /* The variable has been stored in long_ret for
             you to use, and you have just been asked to do something with
             it.  Note that anything done here must be reversable in the UNDO case */
          break;


        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;


        case COMMIT:
             /* Things are working well, so it's now safe to make the change
             permanently.  Make sure that anything done here can't fail! */
          break;
  }
  return SNMP_ERR_NOERROR;
}




int
write_upsConfigInputVoltage(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
  static long *long_ret;
  int size;


  switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER){
              fprintf(stderr, "write to upsConfigInputVoltage not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long_ret)){
              fprintf(stderr,"write to upsConfigInputVoltage: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;


        case RESERVE2:
          size = var_val_len;
          long_ret = (long *) var_val;


          break;


        case FREE:
             /* Release any resources that have been allocated */
          break;


        case ACTION:
             /* The variable has been stored in long_ret for
             you to use, and you have just been asked to do something with
             it.  Note that anything done here must be reversable in the UNDO case */
          break;


        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;


        case COMMIT:
             /* Things are working well, so it's now safe to make the change
             permanently.  Make sure that anything done here can't fail! */
          break;
  }
  return SNMP_ERR_NOERROR;
}




int
write_upsConfigInputFreq(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
  static long *long_ret;
  int size;


  switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER){
              fprintf(stderr, "write to upsConfigInputFreq not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long_ret)){
              fprintf(stderr,"write to upsConfigInputFreq: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;


        case RESERVE2:
          size = var_val_len;
          long_ret = (long *) var_val;


          break;


        case FREE:
             /* Release any resources that have been allocated */
          break;


        case ACTION:
             /* The variable has been stored in long_ret for
             you to use, and you have just been asked to do something with
             it.  Note that anything done here must be reversable in the UNDO case */
          break;


        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;


        case COMMIT:
             /* Things are working well, so it's now safe to make the change
             permanently.  Make sure that anything done here can't fail! */
          break;
  }
  return SNMP_ERR_NOERROR;
}




int
write_upsConfigOutputVoltage(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
  static long *long_ret;
  int size;


  switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER){
              fprintf(stderr, "write to upsConfigOutputVoltage not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long_ret)){
              fprintf(stderr,"write to upsConfigOutputVoltage: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;


        case RESERVE2:
          size = var_val_len;
          long_ret = (long *) var_val;


          break;


        case FREE:
             /* Release any resources that have been allocated */
          break;


        case ACTION:
             /* The variable has been stored in long_ret for
             you to use, and you have just been asked to do something with
             it.  Note that anything done here must be reversable in the UNDO case */
          break;


        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;


        case COMMIT:
             /* Things are working well, so it's now safe to make the change
             permanently.  Make sure that anything done here can't fail! */
          break;
  }
  return SNMP_ERR_NOERROR;
}




int
write_upsConfigOutputFreq(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
  static long *long_ret;
  int size;


  switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER){
              fprintf(stderr, "write to upsConfigOutputFreq not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long_ret)){
              fprintf(stderr,"write to upsConfigOutputFreq: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;


        case RESERVE2:
          size = var_val_len;
          long_ret = (long *) var_val;


          break;


        case FREE:
             /* Release any resources that have been allocated */
          break;


        case ACTION:
             /* The variable has been stored in long_ret for
             you to use, and you have just been asked to do something with
             it.  Note that anything done here must be reversable in the UNDO case */
          break;


        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;


        case COMMIT:
             /* Things are working well, so it's now safe to make the change
             permanently.  Make sure that anything done here can't fail! */
          break;
  }
  return SNMP_ERR_NOERROR;
}




int
write_upsConfigLowBattTime(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
  static long *long_ret;
  int size;


  switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER){
              fprintf(stderr, "write to upsConfigLowBattTime not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long_ret)){
              fprintf(stderr,"write to upsConfigLowBattTime: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;


        case RESERVE2:
          size = var_val_len;
          long_ret = (long *) var_val;


          break;


        case FREE:
             /* Release any resources that have been allocated */
          break;


        case ACTION:
             /* The variable has been stored in long_ret for
             you to use, and you have just been asked to do something with
             it.  Note that anything done here must be reversable in the UNDO case */
          break;


        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;


        case COMMIT:
             /* Things are working well, so it's now safe to make the change
             permanently.  Make sure that anything done here can't fail! */
          break;
  }
  return SNMP_ERR_NOERROR;
}




int
write_upsConfigAudibleStatus(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
  static long *long_ret;
  int size;


  switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER){
              fprintf(stderr, "write to upsConfigAudibleStatus not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long_ret)){
              fprintf(stderr,"write to upsConfigAudibleStatus: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;


        case RESERVE2:
          size = var_val_len;
          long_ret = (long *) var_val;


          break;


        case FREE:
             /* Release any resources that have been allocated */
          break;


        case ACTION:
             /* The variable has been stored in long_ret for
             you to use, and you have just been asked to do something with
             it.  Note that anything done here must be reversable in the UNDO case */
          break;


        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;


        case COMMIT:
             /* Things are working well, so it's now safe to make the change
             permanently.  Make sure that anything done here can't fail! */
          break;
  }
  return SNMP_ERR_NOERROR;
}




int
write_upsConfigLowVoltageTransferPoint(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
  static long *long_ret;
  int size;


  switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER){
              fprintf(stderr, "write to upsConfigLowVoltageTransferPoint not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long_ret)){
              fprintf(stderr,"write to upsConfigLowVoltageTransferPoint: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;


        case RESERVE2:
          size = var_val_len;
          long_ret = (long *) var_val;


          break;


        case FREE:
             /* Release any resources that have been allocated */
          break;


        case ACTION:
             /* The variable has been stored in long_ret for
             you to use, and you have just been asked to do something with
             it.  Note that anything done here must be reversable in the UNDO case */
          break;


        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;


        case COMMIT:
             /* Things are working well, so it's now safe to make the change
             permanently.  Make sure that anything done here can't fail! */
          break;
  }
  return SNMP_ERR_NOERROR;
}




int
write_upsConfigHighVoltageTransferPoint(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
  static long *long_ret;
  int size;


  switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER){
              fprintf(stderr, "write to upsConfigHighVoltageTransferPoint not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long_ret)){
              fprintf(stderr,"write to upsConfigHighVoltageTransferPoint: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;


        case RESERVE2:
          size = var_val_len;
          long_ret = (long *) var_val;


          break;


        case FREE:
             /* Release any resources that have been allocated */
          break;


        case ACTION:
             /* The variable has been stored in long_ret for
             you to use, and you have just been asked to do something with
             it.  Note that anything done here must be reversable in the UNDO case */
          break;


        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;


        case COMMIT:
             /* Things are working well, so it's now safe to make the change
             permanently.  Make sure that anything done here can't fail! */
          break;
  }
  return SNMP_ERR_NOERROR;
}


static void Check_Alarm(unsigned int registrationNumber, void *state)
{
	int i, count, last;
	int current_number = ups->upsobjects.upsalarm.upsAlarmsPresent;

	for ( i = 0 ; i<current_number; i++ ) {
		current_Trap[i] = ups->upsobjects.upsalarm.upsAlarmEntry[i].upsAlarmDescr;
	}
	
	if ( previous_number < current_number ) {
		for ( i = 0; i < current_number; i++ ) {
			printf("Send_Trap_AlarmEntryAdded 1 	--> current_Trap[%d] = %d\n", i, current_Trap[i]);
			Send_Trap_AlarmEntryAdded(current_Trap[i]);
		}
	}
	else if ( previous_number > current_number ) {
		
		count = previous_number - current_number;
		
		if ( current_number == 0 ) 
			last = count;
		else
			last = count + 1;
				
		for ( i = current_number; i < last; i++ ) {
			printf("Send_Trap_AlarmEntryRemoved 2	--> previous_Trap[%d] = %d\n", i, previous_Trap[i]);
			Send_Trap_AlarmEntryRemoved(previous_Trap[i]);
		}
	}
	else if ( (previous_number == current_number) && (current_number != 0) ) {
		for ( i = 0; i < current_number; i++ ) {
			if ( current_Trap[i] != previous_Trap[i] ) {
				Send_Trap_AlarmEntryRemoved(previous_Trap[i]);
				printf("Send_Trap_AlarmEntryRemoved 3 	--> previous_Trap[%d] = %d\n", i, previous_Trap[i]);
				Send_Trap_AlarmEntryAdded(current_Trap[i]);
				printf("Send_Trap_AlarmEntryAdded 3 	--> current_Trap[%d] = %d\n", i, current_Trap[i]);
			}
		}
	}

//	printf("previous_number (%d)  current_number (%d)\n", previous_number, current_number);
	previous_number = current_number;

	for ( i = 0; i<current_number; i++ ) {
		previous_Trap[i] = current_Trap[i];
	}
}

static void Send_Trap_OnBattery()
{
//	if (previous_Trap != current_Trap) 
//	{
		oid trap_OnBattery[] = { 1,3,6,1,2,1,33,2,1 };
		struct variable_list 	var_trap;
		var_trap.next_variable = NULL;
		var_trap.name = trap_OnBattery;
		var_trap.name_length = sizeof(trap_OnBattery)/sizeof(oid);
		var_trap.type = ASN_OBJECT_ID;
		var_trap.val.objid = NULL;
		var_trap.val_len = 0;

		send_v2trap(&var_trap);
		printf("\n Send_Trap_OnBattery()  previous_Trap (%d)  !=  current_Trap  (%d)\n", previous_Trap, current_Trap);
//	}

}

static void Send_Trap_TestCompleted()
{
//	if (previous_Trap != current_Trap) 
//	{
		oid trap_TestCompleted[] = { 1,3,6,1,2,1,33,2,2 };
		struct variable_list 	var_trap;
		var_trap.next_variable = NULL;
		var_trap.name = trap_TestCompleted;
		var_trap.name_length = sizeof(trap_TestCompleted)/sizeof(oid);
		var_trap.type = ASN_OBJECT_ID;
		var_trap.val.objid = NULL;
		var_trap.val_len = 0;

		send_v2trap(&var_trap);
		printf("\n Send_Trap_Testcompleted()  previous_Trap (%d)  !=  current_Trap  (%d)\n", previous_Trap, current_Trap);
//	}

}

static void Send_Trap_AlarmEntryAdded(int number)
{
//	if (previous_Trap != current_Trap) 
//	{
		oid trap_AlarmEntryAdded[] = { 1,3,6,1,2,1,33,2,3 };
		
		struct variable_list 	var_trap;
		var_trap.next_variable = NULL;
		var_trap.name = trap_AlarmEntryAdded;
		var_trap.name_length = sizeof(trap_AlarmEntryAdded)/sizeof(oid);
		var_trap.type = ASN_OBJECT_ID;
		
		switch ( number ) 
		{
		case 1 : var_trap.val.objid = upsAlarmBatteryBad; 		break;
		case 2 : var_trap.val.objid = upsAlarmOnBattery; 		break;
		case 3 : var_trap.val.objid = upsAlarmLowBattery;		break;
		case 4 : var_trap.val.objid = upsAlarmDepletedBattery; 		break;
		case 5 : var_trap.val.objid = upsAlarmTempBad; 			break;
		case 6 : var_trap.val.objid = upsAlarmInputBad; 		break;
		case 7 : var_trap.val.objid = upsAlarmOutputBad; 		break;
		case 8 : var_trap.val.objid = upsAlarmOutputOverload; 		break;
		case 9 : var_trap.val.objid = upsAlarmOnBypass; 		break;
		case 10 : var_trap.val.objid = upsAlarmBypassBad; 		break;
		case 11 : var_trap.val.objid = upsAlarmOutputOffAsRequested; 	break;
		case 12 : var_trap.val.objid = upsAlarmUpsOffAsRequested; 	break;
		case 13 : var_trap.val.objid = upsAlarmChargerFailed; 		break;
		case 14 : var_trap.val.objid = upsAlarmUpsOutputOff; 		break;
		case 15 : var_trap.val.objid = upsAlarmUpsSystemOff; 		break;
		case 16 : var_trap.val.objid = upsAlarmFanFailure; 		break;
		case 17 : var_trap.val.objid = upsAlarmFuseFailure; 		break;
		case 18 : var_trap.val.objid = upsAlarmGeneralFault; 		break;
		case 19 : var_trap.val.objid = upsAlarmDiagnosticTestFailed; 	break;
		case 20 : var_trap.val.objid = upsAlarmCommunicationLost; 	break;
		case 21 : var_trap.val.objid = upsAlarmAwaitingPower; 		break;
		case 22 : var_trap.val.objid = upsAlarmShutdownPending; 	break;
		case 23 : var_trap.val.objid = upsAlarmShutdownImminent; 	break;
		case 24 : var_trap.val.objid = upsAlarmTestInprogress; 		break;
		default : break;
		}
	
      		var_trap.val_len   = sizeof(upsAlarmTestInprogress);

//		printf("sizeof var_trap.val_len = %d\n", sizeof(upsAlarmBatteryBad));


		send_v2trap(&var_trap);
//		printf("Send_Trap_AlarmEntryAdded()\n");
//	}

}

static void Send_Trap_AlarmEntryRemoved(int number)
{
//	if (previous_Trap != current_Trap) 
//	{
		oid trap_AlarmEntryRemoved[] = { 1,3,6,1,2,1,33,2,4 };
		struct variable_list 	var_trap;
		var_trap.next_variable = NULL;
		var_trap.name = trap_AlarmEntryRemoved;
		var_trap.name_length = sizeof(trap_AlarmEntryRemoved)/sizeof(oid);
		var_trap.type = ASN_OBJECT_ID;
	
		switch ( number ) 
		{
		case 1 : var_trap.val.objid = upsAlarmBatteryBad; 		break;
		case 2 : var_trap.val.objid = upsAlarmOnBattery; 		break;
		case 3 : var_trap.val.objid = upsAlarmLowBattery;		break;
		case 4 : var_trap.val.objid = upsAlarmDepletedBattery; 		break;
		case 5 : var_trap.val.objid = upsAlarmTempBad; 			break;
		case 6 : var_trap.val.objid = upsAlarmInputBad; 		break;
		case 7 : var_trap.val.objid = upsAlarmOutputBad; 		break;
		case 8 : var_trap.val.objid = upsAlarmOutputOverload; 		break;
		case 9 : var_trap.val.objid = upsAlarmOnBypass; 		break;
		case 10 : var_trap.val.objid = upsAlarmBypassBad; 		break;
		case 11 : var_trap.val.objid = upsAlarmOutputOffAsRequested; 	break;
		case 12 : var_trap.val.objid = upsAlarmUpsOffAsRequested; 	break;
		case 13 : var_trap.val.objid = upsAlarmChargerFailed; 		break;
		case 14 : var_trap.val.objid = upsAlarmUpsOutputOff; 		break;
		case 15 : var_trap.val.objid = upsAlarmUpsSystemOff; 		break;
		case 16 : var_trap.val.objid = upsAlarmFanFailure; 		break;
		case 17 : var_trap.val.objid = upsAlarmFuseFailure; 		break;
		case 18 : var_trap.val.objid = upsAlarmGeneralFault; 		break;
		case 19 : var_trap.val.objid = upsAlarmDiagnosticTestFailed; 	break;
		case 20 : var_trap.val.objid = upsAlarmCommunicationLost; 	break;
		case 21 : var_trap.val.objid = upsAlarmAwaitingPower; 		break;
		case 22 : var_trap.val.objid = upsAlarmShutdownPending; 	break;
		case 23 : var_trap.val.objid = upsAlarmShutdownImminent; 	break;
		case 24 : var_trap.val.objid = upsAlarmTestInprogress; 		break;
		default : break;
		}
	
      		var_trap.val_len   = sizeof(upsAlarmTestInprogress);

		send_v2trap(&var_trap);
//		printf("Send_Trap_AlarmEntryRemoved()\n");
//	}

}








